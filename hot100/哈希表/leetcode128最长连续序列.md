# LeetCode 热题100

## 一、哈希表

### LeetCode128. 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

* 示例 1:
    > 输入: `nums = [100,4,200,1,3,2]`
    > 输出: `4`
    > 解释：`最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。`


* 示例 2:

    > 输入: `nums = [0,3,7,2,5,8,4,6,0,1]`
    > 输出: `9`

#### 解法：使用哈希集合
**解题思路：** 

我们使用一个集合`（set）`来存储数组中的元素，然后遍历这个集合。对于每个元素，我们检查它是否是某个连续序列的起始点（即前一个元素不在集合中）。如果是，我们就开始向上查找连续的元素，直到找不到为止。

**详细步骤：**
*  `去重与加速查找：`将输入数组转换为集合，去掉重复的元素并支持 O(1) 的查找时间。
*  `查找起始点：`遍历集合中的每个元素，如果 num - 1 不在集合中，则该元素为可能的连续序列的起始点。
*  `查找连续序列：`从起始点开始，使用 while 循环查找下一个连续的元素，并计数。
*  `更新最大长度：`在每次找到新的连续序列后，更新最大长度。

```python
def longestConsecutive(nums):
    # 检查输入列表是否为空，如果为空，返回 0，因为没有连续序列
    if not nums:
        return 0
    
    # 使用集合去重并加速查找
    num_set = set(nums)
    
    # 初始化最大连续序列的计数为 0
    max_count = 0

    # 遍历集合中的每个数字
    for num in num_set:
        # 只在可能的连续序列的起点查找
        # 如果当前数字的前一个数字不在集合中，说明它可能是一个连续序列的起点
        if (num - 1) not in num_set:
            # 将当前数字设为开始数字
            current_num = num
            
            # 初始化当前连续计数为 1（当前数字自身）
            current_count = 1
            
            # 查找连续的数字
            # 继续查找下一个连续的数字
            while (current_num + 1) in num_set:
                current_num += 1  # 将当前数字加 1
                current_count += 1  # 增加当前连续计数
            
            # 更新最长计数
            # 取 max_count 和 current_count 中的较大值，更新 max_count
            max_count = max(max_count, current_count)

    # 返回找到的最大连续序列的长度
    return max_count

```
**运行示例：**
`假设你运行这个函数，传入参数 nums = [100, 4, 200, 1, 3, 2]，你会看到类似以下的输出：`
1. 去重后的集合: {1, 2, 3, 100, 4, 200}
2. 当前数字: 1
- 1 是可能的连续序列的起点
- 找到连续数字: 2, 当前连续计数: 2
- 找到连续数字: 3, 当前连续计数: 3
- 找到连续数字: 4, 当前连续计数: 4
- 更新最大计数: 4
3. 当前数字: 2
4. 当前数字: 3
5. 当前数字: 4
- 4 是可能的连续序列的起点
6. 当前数字: 100
7. 当前数字: 200
- 最长连续序列的长度: 4

